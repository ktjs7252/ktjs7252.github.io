---
layout : post
title : 그래프
---


> 그래프(Graph)
> 그래프의 이해와 종류
- 정점(vertex) : 연결 대상/개체
- 간선(edge) : 정점 사이의 연결


- 무방향 그래프
ㅇ --- ㅇ --- ㅇ

- 방향 그래프(혹은 다이그래프(digraph))
ㅇ --> ㅇ --> ㅇ

- 무방향/방향은 간선 연결형태에 따라 '완전 그래프'로 구분 됨.
- 완전 그래프 : 각각의 정점에서 다른 모든 정점을 연결한 그래프


- 무방향 완전 그래프

   ㅇ
  / \
 ㅇㅡㅇ


- 방향 완전 그래프
    ㅇ
↙↗  ↘↖
ㅇ  ↔  ㅇ

- 간선의 수는 무방향 그래프 간선의 수 x 2


- 가중치 그래프(Weight graph)와 부분 그래프(Sub graph)
- 가중치 그래프 : 무방향이든 방향이든 그래프 간선에 가중치를 두는 그래프

    ㅇ
 3 /  \ 2
 ㅇ ㅡ  ㅇ
    1

- 가중치의 정보는 두 정점 사이의 거리, 걸리는 시간 등 여러 정보가 될 수 있다.


- 부분 그래프 : 원래 그래프의 일부 정점 및 간선으로 이뤄진 그래프.
    ㅇ
 3 /
  ㅇ


- 하나의 예를 들었지만, 이 외에도 원래 그래프를 구성하는 정점/간선의 일부로 이뤄진 그래프는 모두 부분 그래프.


- 그래프의 집합 표현
- 그래프는 정점과 간선의 집합.
- 집합의 표기법을 이용해 표현가능


- 그래프 G의 정점 집합 : V(G)
- 그래프 G의 간선 집합 : E(G)


ex) 그래프 G1
     A
    / \
   B ㅡ C


- 무방향 그래프에선, 정점 A와 B를 연결하는 간선 : (A,B)
- 무방향 그래프에선 방향이 없으므로, (A,B)와 (B,A)는 동일한 간선을 나타냄.


- V(G1) = {A, B, C}
- E(G1) = {(A,B), (A,C), (B,C)}



ex) 그래프 G2
   B
↗
A →  C
↖
  D


- 무방향 그래프와의 차이점은 방향성이 있는 간선의 표시법.
- 정점 A가 정점 C를 가리키는 간선 : <A, C>

- V(G2) = {A, B, C, D}
- E(G2) = {<A,B>, <A,C>, <D,A>}


============================> 그래프 표현과 관련된 내용! 기본적으로 숙지!


> 그래프의 ADT
- void GraphInit(UALGraph* pg, int nv);
- 그래프의 초기화 진행
- 두번째 인자로 정점 수 전달

- void GraphDestory(UALGraph* pg);
- 그래프 초기화 과정에서 할당한 리소스 반환

- void AddEdge(UALGRaph* pg, int fromV, int toV);
- 매개변수 fromV와 toV로 전달된 정점을 연결하는 간선 그래프 추가

- void ShowGraphEdgeInfo(UALGraph* pg);
- 그래프 간선정보 출력

> 그래프를 구현하는 방법

1. 인접행렬(adjacent matrix) 기반 그래프
- 정방 행렬 활용
- 가로 세로 길이가 같은 행렬을 의미
- 이는 2차원 배열로 표현


- 무방향 그래프 표현

  A B C D          B
A 0 1 1 1        /    \
B 1 0 1 1   =>  A ㅡㅡㅡ C
C 1 1 0 1       \      /
D 1 1 1 0          D


- 정점이 4개면 가로세로 길이 4인 2차원 배열 선언
- 두 정점이 연결 되어 있으면 1, 아니면 0으로 표시
- 단, 방향성이 없으므로, 하나의 간선에 대해 두개의 지점을 1로 표시해야 한다.
- 때문에 대각선을 기준으로 대칭 이룸

- 방향 그래프 표현

  B                A B C D
↗  ↘           A 0 1 1 0
A ---> C ==>     B 0 0 1 0
↖   ↙          C 0 0 0 1
   D             D 1 0 0 0


- 무방향 그래프와 달리 대칭을 이루지 않는다.


2. 인접 리스트(adjacent list) 기반 그래프
- 연결 리스트 활용


- 무방향 그래프
- 4개의 정점/하나의 간선 그래프

  A ㅡ B     A -> [B]
          => B -> [A]
  C    D      C(null)
              D(null)

- 각각의 정점은, 자신과 연결된 정점의 정보를 담기 위해 하나의 연결리스트를 갖는다.

- 4개의 정점/3개의 간선 그래프

       B
     /           A -> [B] -> [C] -> [D]
    A ㅡ  C  =>  B -> [A]
    \            C -> [A]
     D           D -> [A]


- 방향 그래프

     B           A -> [B] -> [C] -> [D]
   ↗            B(null)
  A --> C  ==>   C(null)
   ↘            D(null)
     D



> 인접 리스트 기반의 그래프 구현

- 그래프 구현 관점에서, 무방향 vs 방향 그래프의 유일한 차이점은 연결 리스트에 추가하는 노드의 수
- 이 둘의 구현방법에 큰 차이 없음.
- 굳이 따지면 무방향이 좀 더 복잡. 노드의 수가 두배 더 많기 때문에
- 우리는 좀 더 복잡한 무방향 그래프 구현해보자.

> 이해하기!!!

- ALGraph.h

![그래프헤더](https://user-images.githubusercontent.com/78638160/137269580-859f0011-6245-4f3e-b835-1ec74f48e971.png)



- ALGraph.c

![그래프소스1](https://user-images.githubusercontent.com/78638160/137269809-0f0a19f5-3316-4c86-a25b-831e2cbeb1f4.png)

![그래프소스2](https://user-images.githubusercontent.com/78638160/137269817-37c1eae1-0877-4c3d-a0bb-366ee6156163.png)


- ALGraphMain.c

![그래프메인](https://user-images.githubusercontent.com/78638160/137269827-8c1e2730-90f3-40d1-a095-e3414d1ffb98.png)



- DLinkedList.h, DlinkedList.c 활용



> 실제 알고리즘 풀 땐 vector<int> 이용해서 그래프 표현.
- vector<int> w[5];



> 그래프의 탐색
- 깊이 우선 탐색(DFS : Depth First Search)
- 스택
- 재귀함수

1. 탐색 시작 노드를 스택 넣고 방문 처리.
2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 '하나라도 있으면' 그 노드를 스택에 넣고 방문 처리
방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 수행할 수 없을 때까지 반복

* 노드 방문시 visited 여부를 반드시 검사해야 함.

>> dfs() 함수의 이해.
- 너비 우선 탐색(BFS : Breadth First Search)
- 큐


1. 탐색 시작 노드를 큐에 삽입하고 방문 처리.
2. 큐에서 노드 꺼낸 뒤, 해당 노드의 인접 노드 중 방문하지 않은 노드를 '모두' 큐에 삽입 후 방문 처리.
3. 2번 반복.


>> bfs() 함수 이해.


> 최소 비용 신장 트리
--------------------------------------------------
> 탐색(Search)
- 탐색의 이해 & 보간 탐색
- 이진 탐색 트리
- 균형 잡힌 이진 탐색 트리 : AVL 트리의 이해
- 균형 잡힌 이진 탐색 트리 : AVL 트리의 구현


> 테이블(Table)과 해쉬(Hash)
- 빠른 탐색을 보이는 해쉬 테이블
- 충돌(Collision) 문제의 해결책



vector : 크기가 가변적으로 변하는 배열
- heap에 생성되며 내부적으로 동적할당
- front() : 첫번째 원소
- back() : 마지막 원소
- size() : 원소 개수
- capacity() : 할당된 공간 크기, 부족하면 capacity/2 만큼 계속 realloc() 됨.


vector<int> v; // int형 vector 선언
vector<int> v = {1,2,3}; // 1차원 배열 느낌
- v[i] : 인덱스로 접근가능

vector<int> v[10]; // int형 벡터 배열 생성, 2차원 배열 느낌
- v[i][j] : 인덱스로 접근가능
- 배열 각 원소가 int형 벡터형임.


![메인1](https://user-images.githubusercontent.com/78638160/137270185-d3bbbcf7-b95f-472a-83e6-e658570b9fc8.png)

![메인2](https://user-images.githubusercontent.com/78638160/137270201-ee3c11a8-b5fd-4b8a-8a05-1830ebb7491b.png)

![메인3](https://user-images.githubusercontent.com/78638160/137270217-385232a6-6663-4489-9707-f06e24b2c3be.png)

